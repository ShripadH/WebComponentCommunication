ðŸ“˜ README: Angular + Web Components Communication
ðŸ”¹ Problem

We have an Angular shell application that dynamically loads Web Components (custom elements) as child forms.
The parent Angular component contains a Submit button, and we need:

Disable the Submit button until the child form is valid.

Capture child form data when the parentâ€™s Submit button is clicked, and pass it to an Angular service.

Manage subscriptions/unsubscriptions since components load/unload dynamically.

ðŸ”¹ Optimized Solution

Weâ€™ll use Custom DOM Events from the Web Component, and Event Binding in Angular to communicate.

Child Web Component will emit:

formStatusChange â†’ sends { valid: boolean }

formDataSubmit â†’ sends { data: ... }

Angular Parent will:

Listen to these events via Renderer2 or Angularâ€™s @HostListener on the component.

Maintain a flag (isFormValid) to enable/disable Submit.

On Submit click, request the form data from child OR use last cached data.

ðŸ”¹ Child Web Component (Example: <my-form>)
// my-form.ts (Web Component)
export class MyForm extends HTMLElement {
  private form: HTMLFormElement;
  private data: Record<string, any> = {};

  constructor() {
    super();
    this.attachShadow({ mode: "open" });
    this.form = document.createElement("form");
    this.shadowRoot?.appendChild(this.form);

    // Example input
    const input = document.createElement("input");
    input.type = "text";
    input.name = "username";
    this.form.appendChild(input);

    // Listen for changes
    this.form.addEventListener("input", () => this.checkValidity());
  }

  private checkValidity() {
    const isValid = this.form.checkValidity();
    this.dispatchEvent(
      new CustomEvent("formStatusChange", {
        detail: { valid: isValid },
        bubbles: true,
        composed: true,
      })
    );

    // Keep cached data
    const formData = new FormData(this.form);
    this.data = Object.fromEntries(formData.entries());
  }

  public getFormData() {
    return this.data;
  }
}

customElements.define("my-form", MyForm);

ðŸ”¹ Parent Angular Component
// parent.component.ts
import { Component, ElementRef, Renderer2, ViewChild, OnDestroy, AfterViewInit } from '@angular/core';
import { MyService } from './my.service';

@Component({
  selector: 'app-parent',
  template: `
    <my-form #childForm></my-form>
    <button (click)="onSubmit()" [disabled]="!isFormValid">Submit</button>
  `
})
export class ParentComponent implements AfterViewInit, OnDestroy {
  @ViewChild('childForm', { static: true }) childFormRef!: ElementRef;
  private unlisteners: (() => void)[] = [];
  isFormValid = false;
  private cachedData: any = {};

  constructor(private renderer: Renderer2, private myService: MyService) {}

  ngAfterViewInit() {
    const nativeEl = this.childFormRef.nativeElement;

    // Listen to validity changes
    const statusListener = this.renderer.listen(nativeEl, 'formStatusChange', (event: any) => {
      this.isFormValid = event.detail.valid;
      this.cachedData = nativeEl.getFormData(); // cache last form data
    });

    this.unlisteners.push(statusListener);
  }

  onSubmit() {
    const formData = this.childFormRef.nativeElement.getFormData();
    this.myService.processForm(formData);
  }

  ngOnDestroy() {
    this.unlisteners.forEach(unlisten => unlisten());
  }
}

ðŸ”¹ Angular Service
// my.service.ts
import { Injectable } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class MyService {
  processForm(data: any) {
    console.log("Form submitted:", data);
    // Call API, save, etc.
  }
}

ðŸ”¹ Key Points

One-way data (status) â†’ formStatusChange tells Angular whether to enable the button.

Two-way data (on demand) â†’ Parent calls getFormData() to fetch latest data.

Subscription management â†’ Use Renderer2.listen() and cleanup in ngOnDestroy.

Optimized runtime handling â†’ Only listen when the Web Component exists.

âœ… This approach ensures decoupling (web component is reusable anywhere),
âœ… No memory leaks (clean up listeners),
âœ… Works with multiple child components dynamically.
